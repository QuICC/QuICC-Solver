/**
 * @file @Algorithm@SplittingTest.cpp
 * @brief Tests for the @Algorithm@ splitting
 */


// Configuration includes
//

// System includes
//
#include <catch2/catch.hpp>
#include <fstream>

// Project includes
//
#include "QuICC/QuICCEnv.hpp"
#include "QuICC/LoadSplitter/LoadSplitter.hpp"
#include "QuICC/SpatialScheme/3D/@Scheme@.hpp"
#include "QuICC/Enums/GridPurpose.hpp"
#include "QuICC/Enums/VectorFormulation.hpp"
#include "QuICC/TestSuite/Framework/LoadSplitter/TestArgs.hpp"

namespace currentts = ::QuICC::TestSuite::Framework::LoadSplitter;

TEST_CASE( "Tubular splitting test", "[@Algorithm@::@Scheme@]" ){
   // Init Environment
   QuICC::QuICCEnv();

   // Set default arguments if required
   if(currentts::args().useDefault)
   {
      currentts::args().op = "P";
      if(currentts::args().db == 0)
      {
         currentts::args().db = 108;
      }
      if(currentts::args().np == 0)
      {
         currentts::args().np = 8;
      }
      currentts::args().dim1D = 0;

      currentts::args().params.clear();
      for(unsigned int i = 0; i < currentts::args().np; i++)
      {
         currentts::args().params.push_back(i);
      }
   }
   else
   {
      if(currentts::args().db < 1 || currentts::args().np < 1)
      {
         throw std::logic_error("At least database ID (--db) and number of nodes (--np) need to be given");
      }
   }

   int dbId = currentts::args().db - 100;
   if((currentts::args().dim1D == 0) && (dbId > 0) && (dbId < 20))
   {
      unsigned int nM = std::pow(2,dbId);
      currentts::args().dim1D = nM/2 - 1;
      currentts::args().dim2D = nM - 1;
      currentts::args().dim3D = nM - 1;
   }

   if(currentts::args().dim1D == 0 || currentts::args().dim2D == 0 || currentts::args().dim3D == 0)
   {
      throw std::logic_error("Dimensions are not set properly");
   }

   // Get splitting stage
   QuICC::Dimensions::Transform::Id stageId = static_cast<QuICC::Dimensions::Transform::Id>(currentts::args().stage);

   Catch::StringMaker<double>::precision = 15;

   auto op = currentts::args().op;
   auto db = currentts::args().db;
   auto np = currentts::args().np;
   QuICC::ArrayI dim(3);
   dim(0) = currentts::args().dim1D;
   dim(1) = currentts::args().dim2D;
   dim(2) = currentts::args().dim3D;

   // Count all modes
   std::vector<int> tot;

   int refMult = -1;
   for(int id: currentts::args().params)
   {
      QuICC::Parallel::LoadSplitter splitter(id, np);
      auto spScheme = std::make_shared<QuICC::SpatialScheme::@Scheme@>(QuICC::VectorFormulation::TORPOL, QuICC::GridPurpose::SIMULATION);
      auto spBuilder = spScheme->createBuilder(dim, false);
      std::set<QuICC::Splitting::Algorithms::Id> algos = {QuICC::Splitting::Algorithms::TUBULAR};
      auto grp = QuICC::Splitting::Groupers::TRANSFORM;
      splitter.init(spBuilder, algos, grp);
      auto best = splitter.bestSplitting(false);
      auto spRes = best.first;

      if(tot.size() == 0)
      {
         int totModes = -1;
         switch(stageId)
         {
            case QuICC::Dimensions::Transform::TRA1D:
               refMult = currentts::args().dim3D+1;
               totModes = currentts::args().dim2D+1;
               break;
            case QuICC::Dimensions::Transform::TRA2D:
               refMult = spRes->cpu()->dim(QuICC::Dimensions::Transform::TRA1D)->dim<QuICC::Dimensions::Data::DATF1D>();
               totModes = currentts::args().dim3D+1;
               break;
            case QuICC::Dimensions::Transform::TRA3D:
               refMult = spRes->cpu()->dim(QuICC::Dimensions::Transform::TRA2D)->dim<QuICC::Dimensions::Data::DATF1D>();
               totModes = spRes->cpu()->dim(QuICC::Dimensions::Transform::TRA1D)->dim<QuICC::Dimensions::Data::DATF1D>();
               break;
            default:
               throw std::logic_error("Unkown splitting stage");
               break;
         }
         tot = std::vector<int>(totModes, 0);
      }

      int nModes = spRes->cpu()->dim(stageId)->dim<QuICC::Dimensions::Data::DAT3D>();

      std::ofstream metaFile;
      if(currentts::args().dumpData)
      {
         std::stringstream ss;
         ss << "_id" << db;
         ss << "_np" << np;
         ss << "_r" << id;
         std::string fname = op + ss.str() + "_meta.dat";
         metaFile.open(fname);
         if(! metaFile.is_open())
         {
            throw std::logic_error("Couldn't open output file!");
         }

         metaFile << 2+2*nModes << std::endl;
         metaFile << spRes->cpu()->dim(stageId)->dim<QuICC::Dimensions::Data::DATB1D>() << std::endl;
         metaFile << spRes->cpu()->dim(stageId)->dim<QuICC::Dimensions::Data::DATF1D>() << std::endl;
      }

      for(int i = 0; i < nModes; i++)
      {
         int m = spRes->cpu()->dim(stageId)->idx<QuICC::Dimensions::Data::DAT3D>(i);
         int mult = spRes->cpu()->dim(stageId)->dim<QuICC::Dimensions::Data::DAT2D>(i);
         // Accumulate modes
         tot.at(m) += mult;

         if(metaFile.is_open())
         {
            metaFile << m << std::endl;
            metaFile << mult << std::endl;
         }
      }

      if(metaFile.is_open())
      {
         metaFile.close();
      }
   }

   // If all ID are computed, check total
   if(currentts::args().params.size() == currentts::args().np)
   {
      CHECK( refMult > 0 );

      INFO( "ref:  " << refMult );
      for(std::size_t m = 0; m < tot.size(); m++)
      {
         INFO( "m: " << m );
         // Triangular truncation for l,m pairs
         if(stageId == QuICC::Dimensions::Transform::TRA1D)
         {
            CHECK(tot.at(m) == static_cast<int>(m+1));
         } else
         {
            CHECK(tot.at(m) == refMult);
         }
      }
   }
   else
   {
      CHECK( true );
   }
}

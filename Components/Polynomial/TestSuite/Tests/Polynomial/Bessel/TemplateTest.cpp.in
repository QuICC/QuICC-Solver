/**
 * @file @Operator@Test.cpp
 * @brief Tests for the Bessel @Operator@ operator
 */

// Configuration includes
//

// System includes
//
#include <catch2/catch.hpp>
#include <string>

// Project includes
//
#include "QuICC/Polynomial/Bessel/@Operator@.hpp"
#include "QuICC/Polynomial/Bessel/Insulating.hpp"
#include "QuICC/Polynomial/Bessel/Value.hpp"
#include "QuICC/TestSuite/Polynomial/Bessel/TestArgs.hpp"
#include "QuICC/TestSuite/Polynomial/Bessel/Tester.hpp"

#cmakedefine01 Template
#if Template == 1
#define OPERATOR @Field@<@Operator@<@Template@>>
#define FNAME "@Field@_@Operator@_@Template@.dat"
#else
#define OPERATOR @Field@<@Operator@>
#define FNAME "@Field@_@Operator@.dat"
#endif
#undef Template

namespace currentts = ::QuICC::TestSuite::Polynomial::Bessel;

TEST_CASE("Error for @Field@_@Operator@_@Template@ operator",
   "[@CatchTestName@]")
{
   // Set default arguments if required
   if (currentts::args().useDefault)
   {
      currentts::args().params.clear();
      currentts::args().ids = {0, 1, 2, 3, 4, 5};
   }

   Catch::StringMaker<double>::precision = 15;

   if (currentts::args().ids.size() == 0)
   {
      REQUIRE(currentts::args().specN > 0);
      REQUIRE(currentts::args().physN > 0);
      REQUIRE(currentts::args().params.size() > 0);
   }

   // Typedef for used operator
   using namespace QuICC::Polynomial::Bessel;
   typedef OPERATOR Operator;
   typedef typename currentts::Tester<Operator> Tester;

   Tester tester(FNAME, currentts::args().dumpData);
   tester.setUlp(currentts::args().ulp);

   Tester::ParameterType params = {-1};

   if (currentts::args().params.size() > 0)
   {
      for (int l: currentts::args().params)
      {
         params.at(0) = l;
         tester.validate(currentts::args().specN, currentts::args().physN,
            params, currentts::args().type);
      }
   }
   else
   {
      for (int i: currentts::args().ids)
      {
         params.at(0) = i;
         tester.validate(params, currentts::args().type);
      }
   }
}

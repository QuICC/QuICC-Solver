/**
 * @file @Op@@Tag@.hpp.inc
 * @brief Wrapper of the Worland @Op@ Reductor
 */
#pragma once
@Layout@

// System includes
//
#include <vector>
#include <complex>
@HppHeaders@

// Project includes
//
#include "Types/Typedefs.hpp"
#include "QuICC/Transform/Poly/Worland/Reductor/IWorlandPower.hpp"
#include "QuICC/Transform/Poly/Worland/Reductor/IWorlandReductor.hpp"
#include "QuICC/Transform/Poly/Worland/Tags.hpp"
#include "View/View.hpp"
#include "Operator/Unary.hpp"
#include "Operator/Nary.hpp"

namespace QuICC {
namespace Transform {
namespace Poly {
namespace Worland {
namespace Reductor {

using namespace QuICC::Memory;
template <class Impl>
class @Op@;

/**
* @brief Implementation of the Worland based @Op@ Reductor
*/
template<>
class @Op@<@Tag@>: public IWorlandPower
{
public:

    /**
     * @brief Constructor
     */
    @Op@();

    /**
     * @brief Destructor
     */
    ~@Op@() = default;

    /**
     * @brief Rows of output data
     */
    int outRows() const final
    {
        return @SizeRow@
    }

    /**
     * @brief Columns of output data
     */
    int outCols() const final
    {
        return @SizeCol@
    }

private:
    /// @brief Replace base Reductor init
    /// we need to be able to propagate igrid/iweights to view ctor
    /// @param igrid
    /// @param iweights
    void initOperators(const Internal::Array& igrid, const Internal::Array& iweights) const final;


    /// @brief Make operator
    /// this is not used in the view implementations
    /// @param op
    /// @param eop
    /// @param igrid
    /// @param iweights
    /// @param i
    void makeOperator(Matrix& op, Matrix& eop, const Internal::Array& igrid, const Internal::Array& iweights, const int i) const final;

    /// @brief
    /// @param rOut
    /// @param in
    void applyOperators(Matrix& rOut, const MatrixZ& in) const final;

    /// @brief
    /// @param rOut
    /// @param in
    void applyOperators(MatrixZ& rOut, const MatrixZ& in) const final;

    /// @brief Apply ith operator
    /// this is not used in the view implementations
    /// @param rOut
    /// @param i
    /// @param in
    void applyOperator(Eigen::Ref<Matrix> rOut, const int i, const Eigen::Ref<const MatrixZ>& in) const final;

    // Uniform truncation
    #ifdef QUICC_JW_ROW_MAJOR
    using mods_t = View<std::complex<double>, DCCSC3DJIK>;
    using phys_t = View<std::complex<double>, DCCSC3DJIK>;
    using physAbs_t = View<double, DCCSC3DJIK>;
    using modsAbs_t = View<double, DCCSC3DJIK>;
    using modsRed_t = View<double, CSC>;
    using op_t = View<double, @OpAttribute@>;
    #else
    using mods_t = View<std::complex<double>, DCCSC3D>;
    using phys_t = View<std::complex<double>, DCCSC3D>;
    using physAbs_t = View<double, DCCSC3D>;
    using modsAbs_t = View<double, DCCSC3D>;
    using modsRed_t = View<double, CSC>;
    using op_t = View<double, @OpAttribute@JIK>;
    #endif

    /// @brief Projector backend class pointer
    mutable std::unique_ptr<QuICC::Operator::UnaryOp<phys_t, mods_t>> mPrj;

    /// @brief Integrator backend class pointer
    mutable std::unique_ptr<QuICC::Operator::UnaryOp<mods_t, phys_t>> mInt;

    /// @brief Pointwise backend class pointer
    mutable std::unique_ptr<QuICC::Operator::NaryOp<@RedType@Abs_t, @RedType@_t>> mPnt;

    /// @brief Reduction backend class pointer
    mutable std::unique_ptr<QuICC::Operator::UnaryOp<modsRed_t, modsAbs_t>> mRed;

    /// @brief Input View
    mutable mods_t mModsView;

    /// @brief temp/output View
    mutable modsAbs_t mModsAbsView;


    /// @brief temp/output View
    mutable modsRed_t mModsRedView;

    /// @brief temp/output View
    mutable phys_t mPhysView;

    /// @brief temp/output View
    mutable physAbs_t mPhysAbsView;

    /// @brief Temporary storage for flattened input
    mutable std::vector<std::complex<double>> mModsFlat;

    /// @brief Temporary storage for flattened temp/output
    mutable std::vector<double> mModsAbsFlat;

    /// @brief Temporary storage for flattened temp/output
    mutable std::vector<double> mModsRedFlat;

    /// @brief Temporary storage for flattened temp/output
    mutable std::vector<std::complex<double>> mPhysFlat;

    /// @brief Temporary storage for flattened temp/output
    mutable std::vector<double> mPhysAbsFlat;

    /// @brief Data pointers
    mutable std::vector<std::uint32_t> mDataPointers;

    /// @brief Data indices
    mutable std::vector<std::uint32_t> mDataIndices;

    @Storage@
};

} // namespace Reductor
} // namespace Worland
} // namespace Poly
} // namespace Transform
} // namespace QuICC

#include <catch2/catch.hpp>
#include <complex>

#include "View/View.hpp"
#include "View/ViewUtils.hpp"
#include "ViewOps/Fourier/Complex/Diff2D.hpp"
@Header@

using namespace QuICC::View;
using namespace QuICC::Transform::Fourier;

using mods_t = View<std::complex<double>, DCCSC3DInOrder>;

TEST_CASE("Complex Diff 2D Backwards 2002 @Tag@", "[ComplexDiff2DBwd2002@Tag@]")
{
    using namespace QuICC::Transform::Fourier::Complex::@Tag@;

    auto diffOp = std::make_unique<Diff2DOp<mods_t, mods_t, 2, 0, 0, 2, bwd_t>>();

    // mods dims
    constexpr std::size_t M = 5;
    constexpr std::size_t N = 3;
    constexpr std::size_t K = 5;
    std::array<std::uint32_t, 3> dimensions {M, N, K};

    // mods storage
    constexpr std::size_t S = 20;
    std::vector<typename mods_t::ScalarType> modsIn(S);
    std::vector<typename mods_t::ScalarType> modsOut(S);

    // set input modes
    std::size_t i = 0;
    for(; i < M; ++i)
    {
        modsIn[i] = 1.0;
    }
    for(; i < 2*M; ++i)
    {
        modsIn[i] = 0.5;
    }
    for(; i < 3*M; ++i)
    {
        modsIn[i] = 0.25;
    }
    for(; i < 4*M; ++i)
    {
        modsIn[i] = 0.125;
    }

    // host view
    std::array<std::vector<std::uint32_t>, 3> pointers {{{},{0, 2, 2, 2, 3, 4},{}}};
    std::array<std::vector<std::uint32_t>, 3> indices {{{},{0, 1, 0, 0},{}}};
    mods_t modsInV({modsIn.data(), modsIn.size()}, dimensions, pointers, indices);
    mods_t modsOutV({modsOut.data(), modsOut.size()}, dimensions, pointers, indices);

    @View3D@

    // apply
    diffOp->apply(modsOutV, modsInV);

    @CopyBack3D@

    // check
    std::complex<double> c(-1,0);

    CHECK(modsOutV(0,0,0) == 0.0);
    CHECK(modsOutV(1,0,0) == c);
    CHECK(modsOutV(2,1,0) == 2.0*c);
    CHECK(modsOutV(3,0,4) == 2.5*c);
    CHECK(modsOutV(4,0,4) == 2.125*c);

}

TEST_CASE("Complex Diff 2D Forwards 2002 @Tag@", "[ComplexDiff2DFwd2002@Tag@]")
{
    using namespace QuICC::Transform::Fourier::Complex::@Tag@;

    auto diffOp = std::make_unique<Diff2DOp<mods_t, mods_t, 2, 0, 0, 2, fwd_t>>();

    // mods dims
    constexpr std::size_t M = 5;
    constexpr std::size_t N = 3;
    constexpr std::size_t K = 5;
    std::array<std::uint32_t, 3> dimensions {M, N, K};

    // mods storage
    constexpr std::size_t S = 20;
    std::vector<typename mods_t::ScalarType> modsIn(S);
    std::vector<typename mods_t::ScalarType> modsOut(S);

    // set input modes
    std::size_t i = 0;
    for(; i < M; ++i)
    {
        modsIn[i] = 1.0;
    }
    for(; i < 2*M; ++i)
    {
        modsIn[i] = 0.5;
    }
    for(; i < 3*M; ++i)
    {
        modsIn[i] = 0.25;
    }
    for(; i < 4*M; ++i)
    {
        modsIn[i] = 0.125;
    }

    // host view
    std::array<std::vector<std::uint32_t>, 3> pointers {{{},{0, 2, 2, 2, 3, 4},{}}};
    std::array<std::vector<std::uint32_t>, 3> indices {{{},{0, 1, 0, 0},{}}};
    mods_t modsInV({modsIn.data(), modsIn.size()}, dimensions, pointers, indices);
    mods_t modsOutV({modsOut.data(), modsOut.size()}, dimensions, pointers, indices);

    @View3D@

    // apply
    diffOp->apply(modsOutV, modsInV);

    @CopyBack3D@

    // check
    auto fftScale = 1.0 / static_cast<double>(M);
    std::complex<double> c(-fftScale,0);

    CHECK(modsOutV(0,0,0) == 0.0);
    CHECK(modsOutV(1,0,0) == c);
    CHECK(modsOutV(2,1,0) == 2.0*c);
    CHECK(modsOutV(3,0,4) == 2.5*c);
    CHECK(modsOutV(4,0,4) == 2.125*c);

}

TEST_CASE("Complex Inverse Diff 2D Forwards 2002 @Tag@", "[ComplexInvDiff2DFwd2002@Tag@]")
{
    using namespace QuICC::Transform::Fourier::Complex::@Tag@;

    auto diffOp = std::make_unique<Diff2DOp<mods_t, mods_t, 2, 0, 0, 2, fwd_t, inverse_m>>();

    // mods dims
    constexpr std::size_t M = 5;
    constexpr std::size_t N = 3;
    constexpr std::size_t K = 5;
    std::array<std::uint32_t, 3> dimensions {M, N, K};

    // mods storage
    constexpr std::size_t S = 20;
    std::vector<typename mods_t::ScalarType> modsIn(S);
    std::vector<typename mods_t::ScalarType> modsOut(S);

    // set input modes
    std::size_t i = 0;
    for(; i < M; ++i)
    {
        modsIn[i] = 1.0;
    }
    for(; i < 2*M; ++i)
    {
        modsIn[i] = 0.5;
    }
    for(; i < 3*M; ++i)
    {
        modsIn[i] = 0.25;
    }
    for(; i < 4*M; ++i)
    {
        modsIn[i] = 0.125;
    }

    // host view
    std::array<std::vector<std::uint32_t>, 3> pointers {{{},{0, 2, 2, 2, 3, 4},{}}};
    std::array<std::vector<std::uint32_t>, 3> indices {{{},{0, 1, 0, 0},{}}};
    mods_t modsInV({modsIn.data(), modsIn.size()}, dimensions, pointers, indices);
    mods_t modsOutV({modsOut.data(), modsOut.size()}, dimensions, pointers, indices);

    @View3D@

    // apply
    diffOp->apply(modsOutV, modsInV);

    @CopyBack3D@

    // check
    auto fftScale = 1.0 / static_cast<double>(M);
    std::complex<double> c(-fftScale,0);

    double eps = 10.0*std::numeric_limits<double>::epsilon();
    CHECK(modsOutV(0,0,0) == 0.0);
    CHECK(modsOutV(1,0,0) == c);
    CHECK(std::abs(modsOutV(2,1,0) - 0.125*c) < eps);
    CHECK(std::abs(modsOutV(3,0,4) - 0.00625*c) < eps);
    CHECK(std::abs(modsOutV(4,0,4) - 0.007352941176470588*c) < eps);

}
